# Inverted Pendulum
This project implements the logic to process sensor data for an Inverted Pendulum on an FPGA. It consits of 4 basic modules:
- **Button**: This module implements a debouncer for an input signal generated by a button.
- **Encoder**: This module implements a state machine to calculate the position based on the signals generated by an encoder.
- **PWM**: This module implements a PWM signal generator to control the speed of a motor.
- **InvertedPendulum**: This module integrates the previous three modules with the KR260 board.

### Button 
FPGA-implementation to debounce a button input. If the button is pressed, an interrupt is propgated to the CPU. The debouncing logic is based upon the tutorial of [ZipCPU](https://zipcpu.com/blog/2017/08/04/debouncing.html)..
Architecture

The debouncer module receives its input signal from PMOD0 on the KR260 board. The signal is routed through two/three flip-flops before being passed to the debounce counter. This module filters the signal by delaying propagation based on a counter value. Internally, the debounce counter counts down to zero and then forwards the most recent input signal. When the button has been pressed, an interrupt is triggered to the processing system (PS) via interrupt lane defined by the integrating module.

### Encoder
The Encoder module implements the logic to process the phase shifted input signals of a rotary encoder (A and B). Internally the inputs are routed through three flip flops and passed on to a state machine which keeps track of the direction of the rotation by mapping the inputs signals to counter deltas (+1, 0, -1). 
The deltas are accumulated by a counter which is intialized to a user defined reference position (0 by default). The counter value corresponds to the actual position of the device and is passed to the processing system (PS) via a register. Technically the Encoder logic also supports reset upon hitting the index point. However for our Encoder we found that because of the location of the index this is not a useful feature. \\
The implementation also supports updates to the reference position of the counter via a (memory mapped) register. Upon writing to this register the counter is reset to the new reference position and all previous And B signals are ignored.

### PWM
This module implements the internal logic to adjusts a PWM signal based on a user defined threshold. The threshold is also passed to the logic via a (memory mapped) register.

### InvertedPendulum
This is the top-level module integrating the previous three modules with the [KR260 board](https://www.amd.com/de/products/system-on-modules/kria/k26/kr260-robotics-starter-kit.html). For this purpose it is using the [ultrascale-spinal-wrapper](https://github.com/denishoornaert/ultrascale-spinal-wrapper/tree/master) library which already provides the necessary configurations. For memory mapped registers we are using Spinal's `AXI4SlaveFactory` which allows us to define how the registers can be addressed. 
